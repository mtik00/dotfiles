#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

PROFILE="dso-super"
CLUSTER_NAME="DSO-CLUSTER"
HTTPS_PROXY="socks5://127.0.0.1:9999"
DEBUG=0
declare -a REPORT=( )
NG_LIST=""

USAGE=$(cat <<EOF
Usage:
    $(basename "$0") <args>

    Describe GitLab k8s runners, resource request/limits/max, and the nodegroup's
    instance size.

    Arguments:
        -c|--cluster : The name of the cluster to search; default: $CLUSTER_NAME
        -p|--profile : The name of the AWS profile to use; default: $PROFILE
        --proxy      : The HTTPS proxy to use; default: $HTTPS_PROXY
        --debug      : Show debug logs
        -h|--help    : Show this message

    Requirements:
      - Cluster must be public/private
      - kubectl access to the cluster (e.g. 'ssh -D 9999 ews-dso' from your laptop)
      - awscli with AssumableAdmin creds in a profile
      - python >= 3.11
EOF
)

function usage() {
    printf "%s\n" "${USAGE}"
    exit 99
}

FILENAME=$(basename ${BASH_SOURCE[1]-${BASH_SOURCE[0]}})
LEVEL=${LOGLEVEL:-20}
DEBUG=10
INFO=20
WARNING=30
ERROR=40
JSON=${JSONLOGGING:-0}

export COLOR_NC=''
export COLOR_BLACK=''
export COLOR_GRAY=''
export COLOR_RED=''
export COLOR_LIGHT_RED=''
export COLOR_GREEN=''
export COLOR_LIGHT_GREEN=''
export COLOR_BROWN=''
export COLOR_YELLOW=''
export COLOR_BLUE=''
export COLOR_LIGHT_BLUE=''
export COLOR_PURPLE=''
export COLOR_LIGHT_PURPLE=''
export COLOR_CYAN=''
export COLOR_LIGHT_CYAN=''
export COLOR_LIGHT_GRAY=''
export COLOR_WHITE=''

if dircolors > /dev/null 2>&1; then
    export COLOR_NC='\e[0m' # No Color
    export COLOR_BLACK='\e[0;30m'
    export COLOR_GRAY='\e[1;30m'
    export COLOR_RED='\e[0;31m'
    export COLOR_LIGHT_RED='\e[1;31m'
    export COLOR_GREEN='\e[0;32m'
    export COLOR_LIGHT_GREEN='\e[1;32m'
    export COLOR_BROWN='\e[0;33m'
    export COLOR_YELLOW='\e[1;33m'
    export COLOR_BLUE='\e[0;34m'
    export COLOR_LIGHT_BLUE='\e[1;34m'
    export COLOR_PURPLE='\e[0;35m'
    export COLOR_LIGHT_PURPLE='\e[1;35m'
    export COLOR_CYAN='\e[0;36m'
    export COLOR_LIGHT_CYAN='\e[1;36m'
    export COLOR_LIGHT_GRAY='\e[0;37m'
    export COLOR_WHITE='\e[1;37m'
fi

function get_color() {
    local level=$1
    local color="${COLOR_NC}"
    case "${level}" in
        "INFO")
            color="${COLOR_CYAN}"
            ;;
        "WARNING")
            color="${COLOR_YELLOW}"
            ;;
        "ERROR")
            color="${COLOR_RED}"
            ;;
        *)
            color="${COLOR_NC}"
    esac
    echo "${color}"
}

function get_levelno() {
    local level=$1
    local levelno=${INFO}

    shopt -s nocasematch
    case "${level}" in
        debug)
            levelno=${DEBUG}
            ;;
        info)
            levelno=${INFO}
            ;;
        warning)
            levelno=${WARNING}
            ;;
        error)
            levelno=${ERROR}
            ;;
        *)
            levelno=${INFO}
    esac
    echo $levelno
}

function log() {
    local level=$1; shift
    local description="$*"

    if [[ $JSON -eq 1 ]]; then
        local levelno=$(get_levelno "$\{level}")
        printf "{\"time\": \"%(%Y-%m-%d %H:%M:%S %Z)T\", \"level\": \"${level}\", \"levelno\": ${levelno}, \"filename\": \"${FILENAME}\", \"lineno\": ${BASH_LINENO[1]}, \"description\": \"${description}\"}\n"
    else
        local color=$(get_color "${level}")
        printf "%(%Y-%m-%d %H:%M:%S %Z)T [${color} ${level} ${COLOR_NC}] ${FILENAME}:${BASH_LINENO[1]} $*\n"
    fi
}

function log.debug() {
    if [[ $LEVEL -le $DEBUG ]]; then
        log "DEBUG" $*
    fi
}

function log.info() {
    if [[ $LEVEL -le $INFO ]]; then
        log "INFO" $*
    fi
}

function log.warning() {
    if [[ $LEVEL -le $WARNING ]]; then
        log "WARNING" $*
    fi
}

function log.error() {
    if [[ $LEVEL -le $ERROR ]]; then
        log "ERROR" $*
    fi
}

function argparse() {
    while [[ $# -gt 0 ]]; do
    case $1 in
        -c|--cluster)
            CLUSTER_NAME="$2"
            shift 2
            ;;
        -p|--profile)
            PROFILE="$2"
            shift 2
            ;;
        --proxy)
            HTTPS_PROXY="$2"
            shift 2
            ;;
        --debug)
            LEVEL=$DEBUG
            shift
            ;;
        --no-log)
            LEVEL=$WARNING
            shift
            ;;
        -h|--help)
            usage
            ;;
        -*)
            log.error "Unknown option: '$1'"
            usage
            ;;
    esac
    done
}


function validate_args() {
    local error=0
    log.debug "CLUSTER_NAME:'${CLUSTER_NAME}'"
    log.debug "PROFILE:'${PROFILE}'"
    log.debug "HTTPS_PROXY:'${HTTPS_PROXY}'"

    if [[ -z "${CLUSTER_NAME}" ]]; then
        log.error "CLUSTER_NAME must be set"
        error=1
    fi

    if [[ -z "${PROFILE}" ]]; then
        log.error "PROFILE must be set"
        error=1
    fi

    if ! command -v python >/dev/null; then
        log.error "No python found"
        error=1
    fi

    if ! command -v kubectl >/dev/null; then
        log.error "kubectl not found"
        error=1
    fi

    if ! command -v aws >/dev/null; then
        log.error "aws not found"
        error=1
    fi

    if [[ $error -gt 0 ]]; then
        usage
        exit 1
    else
        log.debug "Inputs are valid"
    fi
}

function add_report_line() {
    local line
    printf -v line "$@"
    REPORT+=("$line")
}

function run_proxy_command() {
    if [ -n "${HTTPS_PROXY}" ]; then
        echo "$(HTTPS_PROXY=$HTTPS_PROXY $*)"
    else
       $*
    fi
}

function get_runner_nodegroups() {
    # Search the cluster nodegroups for any nodegroup associated with GitLab.
    # We assume that by the name.
    if [ -z "$NG_LIST" ]; then
        log.debug "Fetching runner nodegroups..."
        NG_LIST=$(aws eks list-nodegroups --profile $PROFILE --cluster-name $CLUSTER_NAME --query "nodegroups[?contains(@, '-runner-')]" --output json)
        log.debug "Found nodegroups: $NG_LIST"
    fi
}

function get_instance_specs() {
    local instance_type=$1

    log.debug "Getting specs for $instance_type"

    local data=$(aws ec2 describe-instance-types --profile $PROFILE --instance-types $instance_type --output json)
    local vcpu_count=$(echo "$data" | jq -r '.InstanceTypes[0].VCpuInfo.DefaultVCpus')
    local memory_mib=$(echo "$data" | jq -r '.InstanceTypes[0].MemoryInfo.SizeInMiB')
    local memory_gib=$(echo "scale=0; $memory_mib / 1024" | bc -l)

    add_report_line "    %s - vCPU: %s; Memory: %sGi" $instance_type $vcpu_count $memory_gib
}

function get_nodegroup_config() {
    local runner_group_label=$1

    # Ensure we have the nodegroup list
    get_runner_nodegroups

    found=1
    while read ng; do
        local data=$(aws eks describe-nodegroup --profile $PROFILE --cluster-name $CLUSTER_NAME --nodegroup-name $ng --output json)
        local runner_group=$(echo "$data" | jq -r '.nodegroup.labels.runnerGroup')
        local ng_name=$(echo "$data" | jq -r '.nodegroup.nodegroupName')

        if [ "$runner_group" = "$runner_group_label" ]; then
            log.debug "...... matched nodegroup label: $runner_group_label; in nodegroup: $ng_name"
            local instance_types=$(echo "$data" | jq -r -c '.nodegroup.instanceTypes[]')

            add_report_line "%s" "  Instance types in nodegroup:"
            for instance_type in $instance_types; do
                get_instance_specs $instance_type
            done

            found=1
            break
        fi
    done < <(echo "$NG_LIST" | jq -r '.[]')

    if [ $found -eq 0 ]; then
        log.warning "Could not find a nodegroup labeled: $runner_group_label"
    fi
}

function get_running_resources() {
    local runner_name=$1
    log.debug "Getting config for: $runner_name"

    local toml="$(run_proxy_command kubectl -n gitlab-runners get cm $runner_name -o jsonpath='{.data.config\.template\.toml}')"

    # The configuration is stored in the config-map as TOML.  Newer versions of `yq` support TOML, however, it doesn't
    # support the config format.  So, on to Python!
    local json=$(echo "$toml" | python -c 'import sys,tomllib,json;print(json.dumps(tomllib.loads(sys.stdin.read())))')
    local default_cpu_limit=$(echo "$json" | jq -r '.runners[0].kubernetes.cpu_limit')
    local default_memory_limit=$(echo "$json" | jq -r '.runners[0].kubernetes.memory_limit')
    local default_cpu_request=$(echo "$json" | jq -r '.runners[0].kubernetes.cpu_request')
    local default_memory_request=$(echo "$json" | jq -r '.runners[0].kubernetes.memory_request')

    local max_override_cpu_limit=$(echo "$json" | jq -r '.runners[0].kubernetes.cpu_limit_overwrite_max_allowed')
    local max_override_memory_limit=$(echo "$json" | jq -r '.runners[0].kubernetes.memory_limit_overwrite_max_allowed')
    local max_override_cpu_request=$(echo "$json" | jq -r '.runners[0].kubernetes.cpu_request_overwrite_max_allowed')
    local max_override_memory_request=$(echo "$json" | jq -r '.runners[0].kubernetes.memory_request_overwrite_max_allowed')

    local runner_group=$(echo "$json" | jq -r '.runners[0].kubernetes.node_selector.runnerGroup')

    add_report_line "%s (%s)" $runner_name $runner_group
    add_report_line "| %12s | %12s | %12s |" "" "Default" "Max Override"
    add_report_line "| %12s | %12s | %12s |" "CPU Request" $default_cpu_request $max_override_cpu_request
    add_report_line "| %12s | %12s | %12s |" "CPU Limit" $default_cpu_limit $max_override_cpu_limit
    add_report_line "| %12s | %12s | %12s |" "Mem Request" $default_memory_request $max_override_memory_request
    add_report_line "| %12s | %12s | %12s |" "Mem Limit" $default_memory_limit $max_override_memory_limit

    get_nodegroup_config $runner_group
}

function main() {
    argparse "$@"
    validate_args

    add_report_line ""
    add_report_line "%s" "     GitLab Runner Resource Configuration"
    add_report_line "%s" "----------------------------------------------"

    for runner in "gitlab-runner-general" "gitlab-runner-cpu" "gitlab-runner-memory"; do
        get_running_resources $runner
        add_report_line ""
    done

    printf "%s\n" "${REPORT[@]}"
}


main "$@"
